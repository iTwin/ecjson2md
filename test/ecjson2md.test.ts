import { ECJsonMarkdownGenerator, formatLink } from "../source/ecjson2md";
import { assert } from "chai";
import { ECJsonBadSearchPath } from "../source/Exception";
import * as fs from "fs";
import * as path from "path";
import * as rimraf from "rimraf";
import { SchemaContext, Schema} from "@bentley/ecjs";

describe("ecjson2md", () => {
  describe("ECJsonMarkdownGenerator", () => {
    describe("Instantiate", () => {
      it("should successfully instantiate with no search dirs", () => {
        const testMDGenerator = new ECJsonMarkdownGenerator([]);
        assert.isDefined(testMDGenerator);
      });

      it("should instantiate with several search dirs", () => {
        const testMDGenerator = new ECJsonMarkdownGenerator([".", "..", "./test/Assets/dir/"]);
        assert.isDefined(testMDGenerator);
      });

      it("should throw an exception for a search dir that doesn't exist", () => {
        let err: Error = new Error();

        try {
          new ECJsonMarkdownGenerator([".", "..", "./badPath"]);
        } catch (exc) {
          err = exc;
        }

        assert.equal(ECJsonBadSearchPath.name, err.name);
      });
    });

    describe("Schema markdown generation", () => {
      const outputDir = path.join(".", "test", "temp");

      // Make the temp dir to store the ouuput
      before(() => {
        if (!fs.existsSync(outputDir))
          fs.mkdirSync(outputDir);
      });

      // Delete the temp dir
      after(() => {
        rimraf.sync(outputDir);
      });

      describe("writeFrontMatter", () => {
        const outputPath = path.join(outputDir, "titleTest.md");
        let testSchema: Schema;

        before(() => {
          testSchema = new Schema();
          testSchema.fromJsonSync
          (JSON.parse(
            '{\
                "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
                "alias":"testSchema",\
                "name": "testSchema",\
                "version":"02.00.00"\
              }'));
        });

        afterEach(() => {
          if (fs.existsSync(outputPath)) fs.unlinkSync(outputPath);
        });

        it("should correctly write the front matter without an alert", () => {
          ECJsonMarkdownGenerator.writeFrontMatter(outputPath, testSchema, false);

          const outputLines = fs.readFileSync(outputPath).toString().split("\n");
          outputLines;

          assert.equal(outputLines[0], "---");
          assert.equal(outputLines[1], "Schema: testSchema");
          assert.equal(outputLines[2], "This file was automatically generated via ecjson2md. Do not edit this file. Any edits made to this file will be overwritten the next time it is generated");
          assert.equal(outputLines[3], "---");
          assert.equal(outputLines[4], "");
          assert.equal(outputLines[5], "");
        });

        it("should correctly write the front matter with an alert", () => {
          ECJsonMarkdownGenerator.writeFrontMatter(outputPath, testSchema, true);

          const outputLines = fs.readFileSync(outputPath).toString().split("\n");
          outputLines;

          assert.equal(outputLines[0], "---");
          assert.equal(outputLines[1], "Schema: testSchema");
          assert.equal(outputLines[2], "This file was automatically generated via ecjson2md. Do not edit this file. Any edits made to this file will be overwritten the next time it is generated");
          assert.equal(outputLines[3], "---");
          assert.equal(outputLines[4], "");
          assert.equal(outputLines[5], '[!alert text="This documentation represents a nonreleased version of this schema" kind="warning"]');
          assert.equal(outputLines[6], "");
          assert.equal(outputLines[7], "");
        });
      });

      describe("writeTitle", () => {
        const outputFilePath = path.join(outputDir, "titleTest.md");

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("should write the title properly for a schema with no description", () => {
          const testSchema = new Schema();
          testSchema.fromJsonSync
          (JSON.parse(
            '{\
                "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
                "alias":"testSchema",\
                "name": "testSchema",\
                "version":"02.00.00"\
              }'));

          ECJsonMarkdownGenerator.writeTitle(outputFilePath, testSchema);

          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          assert.equal(outputLines[0], "# testSchema");
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "");
        });

        it("should write the title properly for a schema with a description", () => {
          const testSchema = new Schema();
          testSchema.fromJsonSync(JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
              "description":"This is the description",\
              "alias":"testSchema",\
              "name": "testSchema",\
              "version":"02.00.00"\
            }'));

          ECJsonMarkdownGenerator.writeTitle(outputFilePath, testSchema);

          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          assert.equal(outputLines[0], "# testSchema");
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "This is the description");
          assert.equal(outputLines[3], "");
          assert.equal(outputLines[4], "");
        });
      });

      describe("write schema item name", () => {
        const outputFilePath = path.join(outputDir, "nameTest.md");

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("shouldn't write anything for an undefined name", () => {
          // Arrange
          const name = undefined;

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemName(outputFilePath, name);

          // Assert
          assert.isFalse(fs.existsSync(outputFilePath));
        });

        it("should properly write the name of a schema item", () => {
          // Arrange
          const name = "NameOfTheSchemaItem";

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemName(outputFilePath, name);

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], "### " + name);
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "");
        });
      });

      describe("write schema item description", () => {
        const outputFilePath = path.join(outputDir, "descriptionTest.md");

        beforeEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("shouldn't write anything for an undefined description", () => {
          // Arrange
          const description = undefined;

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemDescription(outputFilePath, description);

          // Assert
          assert.isFalse(fs.existsSync(outputFilePath));
        });

        it("should properly write the description of a schema item", () => {
          // Arrange
          const description = "This is the description";

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemDescription(outputFilePath, description);

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], description);
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "");
        });
      });

      describe("write schema item label", () => {
        const outputFilePath = path.join(outputDir, "labelTest.md");

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("shouldn't write anything for an undefined label", () => {
          // Arrange
          const label = undefined;

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemLabel(outputFilePath, label);

          // Assert
          assert.isFalse(fs.existsSync(outputFilePath));
        });

        it("should properly write the label of a schema item", () => {
          // Arrange
          const label = "TestLabel";

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemLabel(outputFilePath, label);

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], "**Label:** " + label);
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "");
        });
      });

      describe("write schema item priority", () => {
        const outputFilePath = path.join(outputDir, "priorityTest.md");

        it("shouldn't write anything for an undefined priority", () => {
          // Arrange
          const priority = undefined;

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemPriority(outputFilePath, priority);

          // Assert
          assert.isFalse(fs.existsSync(outputFilePath));
        });

        it("should properly write the priority of a schema item", () => {
          // Arrange
          const priority = 0;

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemPriority(outputFilePath, priority);

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], "**Priority:** " + priority);
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "");
        });
      });

      describe("write schema item modifier", () => {
        const outputFilePath = path.join(outputDir, "modifierTest.md");

        it("shouldn't write anything for an undefined modifier", () => {
          // Arrange
          const modifier = undefined;

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemModifier(outputFilePath, modifier);

          // Assert
          assert.isFalse(fs.existsSync(outputFilePath));
        });

        it("should properly write the modifier of a schema item", () => {
          // Arrange
          const modifier = 1;

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemPriority(outputFilePath, modifier);

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], "**Priority:** " + modifier);
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "");
        });
      });

      describe("writeSchemaItemBaseClass", () => {
        const outputFilePath = path.join(outputDir, "baseClassTest.md");

        it("shouldn't write anything an undefined base class", () => {
          // Arrange
          const baseClass = undefined;

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemBaseClass(outputFilePath, baseClass);

          // Assert
          assert.isFalse(fs.existsSync(outputFilePath));
        });

        it("should write the base class properly", async () => {
          // Arrange
          const schemaJson = JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
              "description":"This is the description",\
              "alias":"testSchema",\
              "name": "testSchema",\
              "version":"02.00.00",\
              "items": { \
                "EntityClassA": {\
                  "description": "this is a description", \
                  "schemaItemType":"EntityClass", \
                  "baseClass" : "testSchema.EntityClassB" \
                },\
                "EntityClassB": {\
                  "description": "this is a description", \
                  "schemaItemType":"EntityClass" \
                }\
              }\
            }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);
          const testBaseClass = ECJsonMarkdownGenerator.getSortedSchemaItems(testSchema, "EntityClass")[0].baseClass;

          // Act
          await ECJsonMarkdownGenerator.writeSchemaItemBaseClass(outputFilePath, testBaseClass);

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], '**Base Class:** [link_to testschema.ecschema/#entityclassb text="testSchema:EntityClassB"]');
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "");
        });
      });

      describe("writeEntityClass", () => {
        const outputFilePath = path.join(outputDir, "entityClassTest.md");

        beforeEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("should properly write an entity class that has just a name and type", async () => {
          // Arrange
          const schemaJson = JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
              "alias":"testSchema",\
              "name": "testSchema",\
              "version":"02.00.00",\
              "items": { \
                "EntityClassA": {\
                  "schemaItemType":"EntityClass" \
                }\
              }\
            }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);
          testSchema.getItemSync("EntityClassA");

          // Act
          await ECJsonMarkdownGenerator.writeEntityClass(outputFilePath, testSchema.getItemSync("EntityClassA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], "### EntityClassA");
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "**Type:** EntityClass");
          assert.equal(outputLines[3], "");
          assert.equal(outputLines[4], "");
        });

        it("should properly write an entity class that has just a name, type, and description", async () => {
          // Arrange
          const schemaJson = JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
              "description":"This is the description",\
              "alias":"testSchema",\
              "name": "testSchema",\
              "version":"02.00.00",\
              "items": { \
                "EntityClassA": {\
                  "description": "this is a description", \
                  "schemaItemType":"EntityClass" \
                }\
              }\
            }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);
          testSchema.getItemSync("EntityClassA");

          // Act
          await ECJsonMarkdownGenerator.writeEntityClass(outputFilePath, testSchema.getItemSync("EntityClassA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], "### EntityClassA");
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "this is a description");
          assert.equal(outputLines[3], "");
          assert.equal(outputLines[4], "**Type:** EntityClass");
          assert.equal(outputLines[5], "");
          assert.equal(outputLines[6], "");
         });

        it("should properly write an entity class that has just a name, type, and base class", async () => {
          // Arrange
          const schemaJson = JSON.parse(
          '{\
            "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
            "description":"This is the description",\
            "alias":"testSchema",\
            "name": "testSchema",\
            "version":"02.00.00",\
            "items": { \
              "EntityClassA": {\
                "schemaItemType":"EntityClass", \
                "baseClass" : "testSchema.EntityClassB" \
              },\
              "EntityClassB": {\
                "description": "this is a description", \
                "schemaItemType":"EntityClass" \
              }\
            }\
          }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);
          testSchema.getItemSync("EntityClassA");

          // Act
          await ECJsonMarkdownGenerator.writeEntityClass(outputFilePath, testSchema.getItemSync("EntityClassA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], "### EntityClassA");
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "**Type:** EntityClass");
          assert.equal(outputLines[3], "");
          assert.equal(outputLines[4], `**Base Class:** [link_to testschema.ecschema/#entityclassb text="testSchema:EntityClassB"]`);
          assert.equal(outputLines[5], "");
          assert.equal(outputLines[6], "");
        });

        it("should properly write an entity class that has just a name, type, and label", async () => {
          // Arrange
          const schemaJson = JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
              "description":"This is the description",\
              "alias":"testSchema",\
              "name": "testSchema",\
              "version":"02.00.00",\
              "items": { \
                "EntityClassA": {\
                  "schemaItemType":"EntityClass", \
                  "label" : "entityLabel" \
                }\
              }\
            }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);
          testSchema.getItemSync("EntityClassA");

          // Act
          await ECJsonMarkdownGenerator.writeEntityClass(outputFilePath, testSchema.getItemSync("EntityClassA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], "### EntityClassA");
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "**Type:** EntityClass");
          assert.equal(outputLines[3], "");
          assert.equal(outputLines[4], "**Label:** entityLabel");
          assert.equal(outputLines[5], "");
          assert.equal(outputLines[6], "");
        });

        it("should properly write an entity class that has a name, type, description, base class, and label", async () => {
          // Arrange
          const schemaJson = JSON.parse(
          '{\
            "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
            "description":"This is the description",\
            "alias":"testSchema",\
            "name": "testSchema",\
            "version":"02.00.00",\
            "items": { \
              "EntityClassA": {\
                "schemaItemType":"EntityClass", \
                "description":"this is a description", \
                "label":"entityLabel", \
                "baseClass" : "testSchema.EntityClassB" \
              },\
              "EntityClassB": {\
                "description": "this is a description", \
                "schemaItemType":"EntityClass" \
              }\
            }\
          }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);
          testSchema.getItemSync("EntityClassA");

          // Act
          await ECJsonMarkdownGenerator.writeEntityClass(outputFilePath, testSchema.getItemSync("EntityClassA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], "### EntityClassA");
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "this is a description");
          assert.equal(outputLines[3], "");
          assert.equal(outputLines[4], "**Type:** EntityClass");
          assert.equal(outputLines[5], "");
          assert.equal(outputLines[6], '**Base Class:** [link_to testschema.ecschema/#entityclassb text="testSchema:EntityClassB"]');
          assert.equal(outputLines[7], "");
          assert.equal(outputLines[8], "**Label:** entityLabel");
          assert.equal(outputLines[9], "");
          assert.equal(outputLines[10], "");
        });

        it("should properly write an entity class that has properties", async () => {
          // Arrange
          const schemaJson = JSON.parse(
          '{\
            "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema", \
            "description":"This is the description", \
            "alias":"testSchema", \
            "name": "testSchema", \
            "version":"02.00.00", \
            "items": { \
              "EntityClassA": { \
                "schemaItemType":"EntityClass", \
                "properties" : \
                [ \
                  { \
                    "description":"description one", \
                    "name":"NameOne", \
                    "propertyType":"PrimitiveProperty", \
                    "typeName":"string" \
                  }, \
                  { \
                    "extendedTypeName":"Json", \
                    "name":"NameTwo", \
                    "propertyType":"PrimitiveProperty", \
                    "typeName":"string" \
                  }, \
                  { \
                    "description":"description three", \
                    "extendedTypeName":"Json", \
                    "name":"NameThree", \
                    "propertyType":"PrimitiveProperty", \
                    "typeName":"string" \
                  }, \
                  { \
                    "name":"NameFour", \
                    "propertyType":"PrimitiveProperty", \
                    "typeName":"string" \
                  } \
                ] \
              }\
            }\
          }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);
          testSchema.getItemSync("EntityClassA");

          // Act
          await ECJsonMarkdownGenerator.writeEntityClass(outputFilePath, testSchema.getItemSync("EntityClassA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], "### EntityClassA");
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "**Type:** EntityClass");
          assert.equal(outputLines[3], "");
          assert.equal(outputLines[4], "#### Properties");
          assert.equal(outputLines[5], "");
          assert.equal(outputLines[6], "|    Name    |    Description    |    Type    |      Extended Type     |");
          assert.equal(outputLines[7], "|:-----------|:------------------|:-----------|:-----------------------|");
          assert.equal(outputLines[8], "|NameOne|description one|string||");
          assert.equal(outputLines[9], "|NameTwo||string|Json|");
          assert.equal(outputLines[10], "|NameThree|description three|string|Json|");
          assert.equal(outputLines[11], "|NameFour||string||");
          assert.equal(outputLines[12], "");
          assert.equal(outputLines[13], "");
        });
      });

  });
    describe("Misc", () => {
      describe("getSortedSchemaItems", () => {
        const schemaJson = JSON.parse(
        '{\
          "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
          "description":"This is the description",\
          "alias":"testSchema",\
          "name": "testSchema",\
          "version":"02.00.00",\
          "items": { \
            "EntityClassB": {\
              "description": "this is a description", \
              "schemaItemType":"EntityClass"\
            },\
            "EntityClassC":{\
              "schemaItemType":"EntityClass"\
            },\
            "EntityClassA":{\
              "schemaItemType":"EntityClass"\
            },\
            "CustomAttributeClassB":{\
              "schemaItemType":"CustomAttributeClass"\
            },\
            "CustomAttributeClassC":{\
              "schemaItemType":"CustomAttributeClass"\
            },\
            "CustomAttributeClassA":{\
              "schemaItemType":"CustomAttributeClass"\
            },\
            "EnumerationB":{\
              "backingTypeName" : "int", \
              "schemaItemType":"Enumeration"\
            },\
            "EnumerationC":{\
              "backingTypeName" : "int", \
              "schemaItemType":"Enumeration"\
            },\
            "EnumerationA":{\
              "backingTypeName" : "int",  \
              "schemaItemType":"Enumeration"\
            },\
            "KindOfQuantityB":{\
              "schemaItemType":"KindOfQuantity"\
            },\
            "KindOfQuantityC":{\
              "schemaItemType":"KindOfQuantity"\
            },\
            "KindOfQuantityA":{\
              "schemaItemType":"KindOfQuantity"\
            },\
            "RelationshipClassB":{\
              "source" :{\
                "constraintClasses" : [ "testSchema.KindOfQuantityA" ],\
                "multiplicity" : "(0..1)",\
                "polymorphic" : true,\
                "roleLabel" : "owns"\
              },\
              "target" :{\
                "constraintClasses" : [ "testSchema.KindOfQuantityB" ],\
                "multiplicity" : "(0..*)",\
                "polymorphic" : false,\
                "roleLabel" : "is owned by"\
              },\
              "schemaItemType":"RelationshipClass"\
            },\
            "RelationshipClassC":{\
              "source" :{\
                "constraintClasses" : [ "testSchema.KindOfQuantityA" ],\
                "multiplicity" : "(0..1)",\
                "polymorphic" : true,\
                "roleLabel" : "owns"\
              },\
              "target" :{\
                "constraintClasses" : [ "testSchema.KindOfQuantityB" ],\
                "multiplicity" : "(0..*)",\
                "polymorphic" : false,\
                "roleLabel" : "is owned by"\
              },\
              "schemaItemType":"RelationshipClass"\
            },\
            "RelationshipClassA":{\
              "source" :{\
                "constraintClasses" : [ "testSchema.KindOfQuantityA" ],\
                "multiplicity" : "(0..1)",\
                "polymorphic" : true,\
                "roleLabel" : "owns"\
              },\
              "target" :{\
                "constraintClasses" : [ "testSchema.KindOfQuantityB" ],\
                "multiplicity" : "(0..*)",\
                "polymorphic" : false,\
                "roleLabel" : "is owned by"\
              },\
              "schemaItemType":"RelationshipClass"\
            },\
            "MixinB":{\
              "schemaItemType":"Mixin"\
            },\
            "MixinC":{\
              "schemaItemType":"Mixin"\
            },\
            "MixinA":{\
              "schemaItemType":"Mixin"\
            },\
            "PropertyCategoryB":{\
              "schemaItemType":"PropertyCategory"\
            },\
            "PropertyCategoryC":{\
              "schemaItemType":"PropertyCategory"\
            },\
            "PropertyCategoryA":{\
              "schemaItemType":"PropertyCategory"\
            }\
          }\
        }');

        let testSchema: Schema;

        before(() => {
          // Load up the schema
          const context = new SchemaContext();
          testSchema = Schema.fromJsonSync(schemaJson, context);
        });

        it("should return the sorted EntityClasses", () => {
          const sortedItems = ECJsonMarkdownGenerator.getSortedSchemaItems(testSchema, "EntityClass");

          assert.equal(sortedItems[0].name, "EntityClassA");
          assert.equal(sortedItems[1].name, "EntityClassB");
          assert.equal(sortedItems[2].name, "EntityClassC");
        });

        it("should return the sorted CustomAttributeClasses", () => {
          const sortedItems = ECJsonMarkdownGenerator.getSortedSchemaItems(testSchema, "CustomAttributeClass");

          assert.equal(sortedItems[0].name, "CustomAttributeClassA");
          assert.equal(sortedItems[1].name, "CustomAttributeClassB");
          assert.equal(sortedItems[2].name, "CustomAttributeClassC");
        });

        it("should return the sorted Enumerations", () => {
          const sortedItems = ECJsonMarkdownGenerator.getSortedSchemaItems(testSchema, "Enumeration");

          assert.equal(sortedItems[0].name, "EnumerationA");
          assert.equal(sortedItems[1].name, "EnumerationB");
          assert.equal(sortedItems[2].name, "EnumerationC");
        });

        it("should return the sorted KindOfQuantities", () => {
          const sortedItems = ECJsonMarkdownGenerator.getSortedSchemaItems(testSchema, "KindOfQuantity");

          assert.equal(sortedItems[0].name, "KindOfQuantityA");
          assert.equal(sortedItems[1].name, "KindOfQuantityB");
          assert.equal(sortedItems[2].name, "KindOfQuantityC");
        });

        it("should return the sorted RelationshipClasses", () => {
          const sortedItems = ECJsonMarkdownGenerator.getSortedSchemaItems(testSchema, "RelationshipClass");

          assert.equal(sortedItems[0].name, "RelationshipClassA");
          assert.equal(sortedItems[1].name, "RelationshipClassB");
          assert.equal(sortedItems[2].name, "RelationshipClassC");
        });

        it("should return the sorted Mixins", () => {
          const sortedItems = ECJsonMarkdownGenerator.getSortedSchemaItems(testSchema, "Mixin");

          assert.equal(sortedItems[0].name, "MixinA");
          assert.equal(sortedItems[1].name, "MixinB");
          assert.equal(sortedItems[2].name, "MixinC");
        });

        it("should return the sorted list of property categories", () => {
          const sortedItems = ECJsonMarkdownGenerator.getSortedSchemaItems(testSchema, "PropertyCategory");

          assert.equal(sortedItems[0].name, "PropertyCategoryA");
          assert.equal(sortedItems[1].name, "PropertyCategoryB");
          assert.equal(sortedItems[2].name, "PropertyCategoryC");
        });
      });

      describe("formatLink", () => {
        it("should correctly format a link for bemetalsmith", () => {
          const link = formatLink("https://www.google.com", "Google");
          assert.equal(link, '[link_to https://www.google.com text="Google"]');
        });
      });
    });
  });
});

import { ECJsonMarkdownGenerator, formatLink, formatWarningAlert, propertyTypeNumberToString, removeExtraBlankLine } from "../source/ecjson2md";
import { assert } from "chai";
import { ECJsonBadSearchPath } from "../source/Exception";
import * as fs from "fs";
import * as path from "path";
import * as rimraf from "rimraf";
import { SchemaContext, Schema, PropertyType} from "@bentley/ecschema-metadata";

describe("ecjson2md", () => {
  describe("ECJsonMarkdownGenerator", () => {
    describe("Instantiate", () => {
      it("should successfully instantiate with no search dirs", () => {
        const testMDGenerator = new ECJsonMarkdownGenerator([]);
        assert.isDefined(testMDGenerator);
      });

      it("should instantiate with several search dirs", () => {
        const testMDGenerator = new ECJsonMarkdownGenerator([".", "..", "./test/Assets/dir/"]);
        assert.isDefined(testMDGenerator);
      });

      it("should throw an exception for a search dir that doesn't exist", () => {
        let err: Error = new Error();

        try {
          new ECJsonMarkdownGenerator([".", "..", "./badPath"]);
        } catch (exc) {
          err = exc;
        }

        assert.equal(ECJsonBadSearchPath.name, err.name);
      });
    });

    describe("Schema markdown generation", () => {
      const outputDir = path.join(".", "test", "temp");

      // Make the temp dir to store the output
      before(() => {
        if (!fs.existsSync(outputDir))
          fs.mkdirSync(outputDir);
      });

      // Delete the temp dir
      after(() => {
        rimraf.sync(outputDir);
      });

      describe("writeFrontMatter", () => {
        const outputPath = path.join(outputDir, "titleTest.md");
        let testSchema: Schema;

        before(() => {
          testSchema = new Schema();
          testSchema.fromJsonSync
          (JSON.parse(
            '{\
                "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
                "alias":"testSchema",\
                "name": "testSchema",\
                "version":"02.00.00"\
              }'));
        });

        beforeEach(() => {
          if (fs.existsSync(outputPath)) fs.unlinkSync(outputPath);
        });

        afterEach(() => {
          if (fs.existsSync(outputPath)) fs.unlinkSync(outputPath);
        });

        it("should correctly write the front matter without an alert", () => {
          // Act
          ECJsonMarkdownGenerator.writeFrontMatter(outputPath, testSchema, false);

          // Assert
          const outputLines = fs.readFileSync(outputPath).toString().split("\n");
          outputLines;
          assert.equal(outputLines[0], "---");
          assert.equal(outputLines[1], "Schema: testSchema");
          assert.equal(outputLines[2], "This file was automatically generated via ecjson2md. Do not edit this file. Any edits made to this file will be overwritten the next time it is generated");
          assert.equal(outputLines[3], "---");
          assert.equal(outputLines[4], "");
          assert.equal(outputLines[5], "");
        });

        it("should correctly write the front matter with an alert", () => {
          // Act
          ECJsonMarkdownGenerator.writeFrontMatter(outputPath, testSchema, true);

          // Assert
          const outputLines = fs.readFileSync(outputPath).toString().split("\n");
          outputLines;
          assert.equal(outputLines[0], "---");
          assert.equal(outputLines[1], "Schema: testSchema");
          assert.equal(outputLines[2], "This file was automatically generated via ecjson2md. Do not edit this file. Any edits made to this file will be overwritten the next time it is generated");
          assert.equal(outputLines[3], "---");
          assert.equal(outputLines[4], "");
          assert.equal(outputLines[5], '[!alert text="This documentation represents a nonreleased version of this schema" kind="warning"]');
          assert.equal(outputLines[6], "");
          assert.equal(outputLines[7], "");
        });
      });

      describe("writeSchema", () => {
        const outputFilePath = path.join(outputDir, "titleTest.md");

        beforeEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("should write the markdown properly for a schema with no description or label", () => {
          // Arrange
          const testSchema = new Schema();
          testSchema.fromJsonSync(JSON.parse(
            '{\
                "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
                "alias":"testSchema",\
                "name": "testSchema",\
                "version":"02.00.00"\
              }'));

          // Act
          ECJsonMarkdownGenerator.writeSchema(outputFilePath, testSchema);

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          const correctLines = [
            "# testSchema",
            "",
            "**alias:** testSchema",
            "",
            "**version:** 2.0.0",
            "",
            "" ];

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should write the markdown properly for a schema with a description", () => {
          // Arrange
          const testSchema = new Schema();
          testSchema.fromJsonSync(JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
              "description":"This is the description",\
              "alias":"testSchema",\
              "name": "testSchema",\
              "version":"02.00.00"\
            }'));

          // Act
          ECJsonMarkdownGenerator.writeSchema(outputFilePath, testSchema);

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          const correctLines = [
            "# testSchema",
            "",
            "**alias:** testSchema",
            "",
            "**version:** 2.0.0",
            "",
            "This is the description",
            "",
            "" ];

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should write the markdown properly for a schema with a description and label", () => {
          // Arrange
          const testSchema = new Schema();
          testSchema.fromJsonSync(JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
              "description":"This is the description",\
              "alias":"testSchema",\
              "name": "testSchema",\
              "label": "testSchemaLabel", \
              "version":"02.00.00"\
            }'));

          // Act
          ECJsonMarkdownGenerator.writeSchema(outputFilePath, testSchema);

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          const correctLines = [
            "# testSchema",
            "",
            "**alias:** testSchema",
            "",
            "**version:** 2.0.0",
            "",
            "This is the description",
            "",
            "**displayLabel:** testSchemaLabel",
            "",
            "" ];

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });
      });

      describe("writeSchemaItemName", () => {
        const outputFilePath = path.join(outputDir, "nameTest.md");

        beforeEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("shouldn't write anything for an undefined name", () => {
          // Arrange
          const name = undefined;

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemName(outputFilePath, name);

          // Assert
          assert.isFalse(fs.existsSync(outputFilePath));
        });

        it("should properly write the name of a schema item", () => {
          // Arrange
          const name = "NameOfTheSchemaItem";

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemName(outputFilePath, name);

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], "### " + name);
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "");
        });
      });

      describe("writeSchemaItemDescription", () => {
        const outputFilePath = path.join(outputDir, "descriptionTest.md");

        beforeEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("shouldn't write anything for an undefined description", () => {
          // Arrange
          const description = undefined;

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemDescription(outputFilePath, description);

          // Assert
          assert.isFalse(fs.existsSync(outputFilePath));
        });

        it("should properly write the description of a schema item", () => {
          // Arrange
          const description = "This is the description";

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemDescription(outputFilePath, description);

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], description);
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "");
        });
      });

      describe("writeSchemaItemLabel", () => {
        const outputFilePath = path.join(outputDir, "labelTest.md");

        beforeEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("shouldn't write anything for an undefined label", () => {
          // Arrange
          const label = undefined;

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemLabel(outputFilePath, label);

          // Assert
          assert.isFalse(fs.existsSync(outputFilePath));
        });

        it("should properly write the label of a schema item", () => {
          // Arrange
          const label = "TestLabel";

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemLabel(outputFilePath, label);

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], "**displayLabel:** " + label);
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "");
        });
      });

      describe("writeSchemaItemPriority", () => {
        const outputFilePath = path.join(outputDir, "priorityTest.md");

        beforeEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("shouldn't write anything for an undefined priority", () => {
          // Arrange
          const priority = undefined;

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemPriority(outputFilePath, priority);

          // Assert
          assert.isFalse(fs.existsSync(outputFilePath));
        });

        it("should properly write the priority of a schema item", () => {
          // Arrange
          const priority = 0;

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemPriority(outputFilePath, priority);

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], "**priority:** " + priority);
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "");
        });
      });

      describe("writeSchemaItemModifier", () => {
        const outputFilePath = path.join(outputDir, "modifierTest.md");

        beforeEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("shouldn't write anything for an undefined modifier", () => {
          // Arrange
          const modifier = undefined;

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemModifier(outputFilePath, modifier);

          // Assert
          assert.isFalse(fs.existsSync(outputFilePath));
        });

        it("should properly write the modifier of a schema item", () => {
          // Arrange
          const modifier = 1;

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemPriority(outputFilePath, modifier);

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], "**priority:** " + modifier);
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "");
        });
      });

      describe("writeSchemaItemBaseClass", () => {
        const outputFilePath = path.join(outputDir, "baseClassTest.md");

        beforeEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("shouldn't write anything an undefined base class", () => {
          // Arrange
          const baseClass = undefined;

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemBaseClass(outputFilePath, baseClass);

          // Assert
          assert.isFalse(fs.existsSync(outputFilePath));
        });

        it("should write the base class properly", () => {
          // Arrange
          const schemaJson = JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
              "description":"This is the description",\
              "alias":"testSchema",\
              "name": "testSchema",\
              "version":"02.00.00",\
              "items": { \
                "EntityClassA": {\
                  "description": "this is a description", \
                  "schemaItemType":"EntityClass", \
                  "baseClass" : "testSchema.EntityClassB" \
                },\
                "EntityClassB": {\
                  "description": "this is a description", \
                  "schemaItemType":"EntityClass" \
                }\
              }\
            }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);
          const testBaseClass = ECJsonMarkdownGenerator.getSortedSchemaItems(testSchema, "EntityClass")[0].baseClass;

          // Act
          ECJsonMarkdownGenerator.writeSchemaItemBaseClass(outputFilePath, testBaseClass);

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], '**baseClass:** [link_to testschema.ecschema/#entityclassb text="testSchema:EntityClassB"]');
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "");
        });
      });

      describe("writeEntityClass", () => {
        const outputFilePath = path.join(outputDir, "entityClassTest.md");

        beforeEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        beforeEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("should properly write an entity class that has just a name and type", () => {
          // Arrange
          const schemaJson = JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
              "alias":"testSchema",\
              "name": "testSchema",\
              "version":"02.00.00",\
              "items": { \
                "EntityClassA": {\
                  "schemaItemType":"EntityClass" \
                }\
              }\
            }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);

          // Act
          ECJsonMarkdownGenerator.writeEntityClass(outputFilePath, testSchema.getItemSync("EntityClassA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          const correctLines = [
            "### EntityClassA",
            "",
            "**typeName:** EntityClass",
            "",
            "**modifier:** None",
            "",
            "" ];

          // tslint:disable-next-line:prefer-for-of

          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write an entity class that has just a name, type, and description", () => {
          // Arrange
          const schemaJson = JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
              "description":"This is the description",\
              "alias":"testSchema",\
              "name": "testSchema",\
              "version":"02.00.00",\
              "items": { \
                "EntityClassA": {\
                  "description": "this is a description", \
                  "schemaItemType":"EntityClass" \
                }\
              }\
            }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);
          testSchema.getItemSync("EntityClassA");

          // Act
          ECJsonMarkdownGenerator.writeEntityClass(outputFilePath, testSchema.getItemSync("EntityClassA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          const correctLines = [
            "### EntityClassA",
            "",
            "**typeName:** EntityClass",
            "",
            "this is a description",
            "",
            "**modifier:** None",
            "",
            "" ];

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
         });

        it("should properly write an entity class that has just a name, type, and base class", () => {
          // Arrange
          const schemaJson = JSON.parse(
          '{\
            "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
            "description":"This is the description",\
            "alias":"testSchema",\
            "name": "testSchema",\
            "version":"02.00.00",\
            "items": { \
              "EntityClassA": {\
                "schemaItemType":"EntityClass", \
                "baseClass" : "testSchema.EntityClassB" \
              },\
              "EntityClassB": {\
                "description": "this is a description", \
                "schemaItemType":"EntityClass" \
              }\
            }\
          }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);
          testSchema.getItemSync("EntityClassA");

          // Act
          ECJsonMarkdownGenerator.writeEntityClass(outputFilePath, testSchema.getItemSync("EntityClassA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          const correctLines = [
            "### EntityClassA",
            "",
            "**typeName:** EntityClass",
            "",
            "**modifier:** None",
            "",
            '**baseClass:** [link_to testschema.ecschema/#entityclassb text="testSchema:EntityClassB"]',
            "",
            "" ];

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write an entity class that has just a name, type, and label", () => {
          // Arrange
          const schemaJson = JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
              "description":"This is the description",\
              "alias":"testSchema",\
              "name": "testSchema",\
              "version":"02.00.00",\
              "items": { \
                "EntityClassA": {\
                  "schemaItemType":"EntityClass", \
                  "label" : "entityLabel" \
                }\
              }\
            }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);
          testSchema.getItemSync("EntityClassA");

          // Act
          ECJsonMarkdownGenerator.writeEntityClass(outputFilePath, testSchema.getItemSync("EntityClassA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          const correctLines = [
            "### EntityClassA",
            "",
            "**typeName:** EntityClass",
            "",
            "**displayLabel:** entityLabel",
            "",
            "**modifier:** None",
            "",
            "" ];

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write an entity class that has a name, type, description, base class, and label", () => {
          // Arrange
          const schemaJson = JSON.parse(
          '{\
            "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
            "description":"This is the description",\
            "alias":"testSchema",\
            "name": "testSchema",\
            "version":"02.00.00",\
            "items": { \
              "EntityClassA": {\
                "schemaItemType":"EntityClass", \
                "description":"this is a description", \
                "label":"entityLabel", \
                "baseClass" : "testSchema.EntityClassB" \
              },\
              "EntityClassB": {\
                "description": "this is a description", \
                "schemaItemType":"EntityClass" \
              }\
            }\
          }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);
          testSchema.getItemSync("EntityClassA");

          // Act
          ECJsonMarkdownGenerator.writeEntityClass(outputFilePath, testSchema.getItemSync("EntityClassA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          const correctLines = [
            "### EntityClassA",
            "",
            "**typeName:** EntityClass",
            "",
            "this is a description",
            "",
            "**displayLabel:** entityLabel",
            "",
            "**modifier:** None",
            "",
            '**baseClass:** [link_to testschema.ecschema/#entityclassb text="testSchema:EntityClassB"]',
            "",
            "" ];

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write an entity class that has properties", () => {
          // Arrange
          const schemaJson = JSON.parse(
          '{\
            "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema", \
            "description":"This is the description", \
            "alias":"testSchema", \
            "name": "testSchema", \
            "version":"02.00.00", \
            "items": { \
              "EntityClassA": { \
                "schemaItemType":"EntityClass", \
                "properties" : \
                [ \
                  { \
                    "description":"description one", \
                    "name":"NameOne", \
                    "propertyType":"PrimitiveProperty", \
                    "typeName":"string" \
                  }, \
                  { \
                    "extendedTypeName":"Json", \
                    "name":"NameTwo", \
                    "propertyType":"PrimitiveProperty", \
                    "typeName":"string" \
                  }, \
                  { \
                    "description":"description three", \
                    "extendedTypeName":"Json", \
                    "name":"NameThree", \
                    "propertyType":"PrimitiveProperty", \
                    "typeName":"string" \
                  }, \
                  { \
                    "name":"NameFour", \
                    "propertyType":"PrimitiveProperty", \
                    "typeName":"string" \
                  } \
                ] \
              }\
            }\
          }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);
          testSchema.getItemSync("EntityClassA");

          // Act
          ECJsonMarkdownGenerator.writeEntityClass(outputFilePath, testSchema.getItemSync("EntityClassA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          const correctLines = [
            "### EntityClassA",
            "",
            "**typeName:** EntityClass",
            "",
            "**modifier:** None",
            "",
            "#### Properties",
            "",
            "|    Name    |    Description    |    Type    |      Extended Type     |",
            "|:-----------|:------------------|:-----------|:-----------------------|",
            "|NameOne|description one|string||",
            "|NameTwo||string|Json|",
            "|NameThree|description three|string|Json|",
            "|NameFour||string||",
            "",
            "" ];

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });
      });

      describe("writeKindfOfQuantityClass", () => {
        const outputFilePath = path.join(outputDir, "entityClassTest.md");

        // Delete the output file before each test
        beforeEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("should properly write a kind of quantity without a description", () => {
          // Arrange
          const schemaJson = JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
              "alias":"testSchema",\
              "name": "testSchema",\
              "version":"02.00.00",\
              "items": { \
                "KindOfQuantityA": {\
                  "schemaItemType":"KindOfQuantity", \
                  "label":"KindOfQuantityA", \
                  "persistenceUnit" : { \
                    "format" : "DefaultReal", \
                    "unit" : "A" \
                  }, \
                 "precision" : 0.0010, \
                 "presentationUnits" : [ \
                    { \
                       "format" : "Real4U", \
                       "unit" : "A" \
                    }, \
                    { \
                       "format" : "Real4U", \
                       "unit" : "KILOAMPERE" \
                    } \
                  ] \
                }\
              }\
            }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);

          // Act
          ECJsonMarkdownGenerator.writeKindOfQuantityClass(outputFilePath, testSchema.getItemSync("KindOfQuantityA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], "### KindOfQuantityA");
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "**typeName:** KindOfQuantity");
          assert.equal(outputLines[3], "");
          assert.equal(outputLines[4], "**displayLabel:** KindOfQuantityA");
          assert.equal(outputLines[5], "");
          assert.equal(outputLines[6], "**Precision:** 0.001");
          assert.equal(outputLines[7], "");
          assert.equal(outputLines[8], "**Persistence Unit:** A");
          assert.equal(outputLines[9], "");
          assert.equal(outputLines[10], "**Default Presentation Unit**: A");
          assert.equal(outputLines[11], "");
          assert.equal(outputLines[12], "**Alternate Presentation Units**");
          assert.equal(outputLines[13], "");
          assert.equal(outputLines[14], "- KILOAMPERE");
          assert.equal(outputLines[15], "");
          assert.equal(outputLines[16], "");
        });

        it("should properly write a kind of quantity without an alternate presentation unit", () => {
          // Arrange
          const schemaJson = JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
              "alias":"testSchema",\
              "name": "testSchema",\
              "version":"02.00.00",\
              "items": { \
                "KindOfQuantityA": {\
                  "schemaItemType":"KindOfQuantity", \
                  "label":"KindOfQuantityA", \
                  "persistenceUnit" : { \
                    "format" : "DefaultReal", \
                    "unit" : "A" \
                  }, \
                  "precision" : 0.0010, \
                  "presentationUnits" : [ \
                    { \
                        "format" : "Real4U", \
                        "unit" : "A" \
                    } \
                  ] \
                }\
              }\
            }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);

          // Act
          ECJsonMarkdownGenerator.writeKindOfQuantityClass(outputFilePath, testSchema.getItemSync("KindOfQuantityA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], "### KindOfQuantityA");
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "**typeName:** KindOfQuantity");
          assert.equal(outputLines[3], "");
          assert.equal(outputLines[4], "**displayLabel:** KindOfQuantityA");
          assert.equal(outputLines[5], "");
          assert.equal(outputLines[6], "**Precision:** 0.001");
          assert.equal(outputLines[7], "");
          assert.equal(outputLines[8], "**Persistence Unit:** A");
          assert.equal(outputLines[9], "");
          assert.equal(outputLines[10], "**Default Presentation Unit**: A");
          assert.equal(outputLines[11], "");
          assert.equal(outputLines[12], "");
        });

        it("should properly write a kind of quantity without a description or alternate presentation unit", () => {
          // Arrange
          const schemaJson = JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
              "alias":"testSchema",\
              "name": "testSchema",\
              "version":"02.00.00",\
              "items": { \
                "KindOfQuantityA": {\
                  "schemaItemType":"KindOfQuantity", \
                  "label":"KindOfQuantityA", \
                  "persistenceUnit" : { \
                    "format" : "DefaultReal", \
                    "unit" : "A" \
                  }, \
                 "precision" : 0.0010, \
                 "presentationUnits" : [ \
                    { \
                       "format" : "Real4U", \
                       "unit" : "A" \
                    } \
                  ] \
                }\
              }\
            }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);

          // Act
          ECJsonMarkdownGenerator.writeKindOfQuantityClass(outputFilePath, testSchema.getItemSync("KindOfQuantityA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], "### KindOfQuantityA");
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "**typeName:** KindOfQuantity");
          assert.equal(outputLines[3], "");
          assert.equal(outputLines[4], "**displayLabel:** KindOfQuantityA");
          assert.equal(outputLines[5], "");
          assert.equal(outputLines[6], "**Precision:** 0.001");
          assert.equal(outputLines[7], "");
          assert.equal(outputLines[8], "**Persistence Unit:** A");
          assert.equal(outputLines[9], "");
          assert.equal(outputLines[10], "**Default Presentation Unit**: A");
          assert.equal(outputLines[11], "");
          assert.equal(outputLines[12], "");
        });

        it("should properly write a kind of quantity with multiple alternate presentation units", () => {
          // Arrange
          const schemaJson = JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
              "alias":"testSchema",\
              "name": "testSchema",\
              "version":"02.00.00",\
              "items": { \
                "KindOfQuantityA": {\
                  "schemaItemType":"KindOfQuantity", \
                  "label":"KindOfQuantityA", \
                  "persistenceUnit" : { \
                    "format" : "DefaultReal", \
                    "unit" : "A" \
                  }, \
                 "precision" : 0.0010, \
                 "presentationUnits" : [ \
                    { \
                       "format" : "Real4U", \
                       "unit" : "A" \
                    }, \
                    { \
                       "format" : "Real4U", \
                       "unit" : "KILOAMPERE" \
                    }, \
                    { \
                      "format" : "Real4U", \
                      "unit" : "M/SEC.SQ" \
                    }, \
                    { \
                      "format" : "Real4U", \
                      "unit" : "CM/SEC.SQ" \
                    }, \
                    { \
                      "format" : "Real4U", \
                      "unit" : "FT/SEC.SQ" \
                    } \
                  ] \
                }\
              }\
            }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);

          // Act
          ECJsonMarkdownGenerator.writeKindOfQuantityClass(outputFilePath, testSchema.getItemSync("KindOfQuantityA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          assert.equal(outputLines[0], "### KindOfQuantityA");
          assert.equal(outputLines[1], "");
          assert.equal(outputLines[2], "**typeName:** KindOfQuantity");
          assert.equal(outputLines[3], "");
          assert.equal(outputLines[4], "**displayLabel:** KindOfQuantityA");
          assert.equal(outputLines[5], "");
          assert.equal(outputLines[6], "**Precision:** 0.001");
          assert.equal(outputLines[7], "");
          assert.equal(outputLines[8], "**Persistence Unit:** A");
          assert.equal(outputLines[9], "");
          assert.equal(outputLines[10], "**Default Presentation Unit**: A");
          assert.equal(outputLines[11], "");
          assert.equal(outputLines[12], "**Alternate Presentation Units**");
          assert.equal(outputLines[13], "");
          assert.equal(outputLines[14], "- KILOAMPERE");
          assert.equal(outputLines[15], "- M/SEC.SQ");
          assert.equal(outputLines[16], "- CM/SEC.SQ");
          assert.equal(outputLines[17], "- FT/SEC.SQ");
          assert.equal(outputLines[18], "");
          assert.equal(outputLines[19], "");
        });
      });

      describe("writeRelationshipClass", () => {
        const outputFilePath = path.join(outputDir, "relationshipClassTest.md");

        // Delete the output file before each test
        beforeEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("should properly write a class without a description, base class, or label", () => {
          // Arrange
          const schemaJson = JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema", \
              "alias":"testSchema", \
              "name": "testSchema", \
              "version":"02.00.00", \
              "items": { \
                "EntityClassA": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassB": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassC": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassD": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "RelationshipClassA": { \
                  "modifier": "none", \
                  "schemaItemType":"RelationshipClass", \
                  "strength" : "referencing", \
                  "strengthDirection" : "forward", \
                  "source" : { \
                    "constraintClasses": [ "testSchema.EntityClassA" ], \
                    "multiplicity" : "(0..*)", \
                    "polymorphic" : false, \
                    "roleLabel": "relates to" \
                  }, \
                  "target" : { \
                    "constraintClasses" : [ "testSchema.EntityClassB" ], \
                    "multiplicity" : "(1..1)", \
                    "polymorphic": true, \
                    "roleLabel": "is related by" \
                  } \
                } \
              } \
            }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);

          // Act
          ECJsonMarkdownGenerator.writeRelationshipClass(outputFilePath, testSchema.getItemSync("RelationshipClassA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
          outputLines;

          const correctLines = [
            "### RelationshipClassA",
            "",
            "**typeName:** RelationshipClass",
            "",
            "**modifier:** None",
            "",
            "**Strength:** Referencing",
            "",
            "**strengthDirection:** Forward",
            "",
            "#### Source",
            "",
            "**isPolymorphic:** false",
            "",
            "**roleLabel:** relates to",
            "",
            "**multiplicity:** (0..*)",
            "",
            "##### Constraint Classes",
            "",
            '- [link_to testschema.ecschema/#entityclassa text="EntityClassA"]',
            "",
            "#### Target",
            "",
            "**isPolymorphic:** true",
            "",
            "**roleLabel:** is related by",
            "",
            "**multiplicity:** (1..1)",
            "",
            "##### Constraint Classes",
            "",
            '- [link_to testschema.ecschema/#entityclassb text="EntityClassB"]',
            "",
            "" ];

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write a class with a description", () => {
          // Arrange
          const schemaJson = JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema", \
              "alias":"testSchema", \
              "name": "testSchema", \
              "version":"02.00.00", \
              "items": { \
                "EntityClassA": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassB": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassC": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassD": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "RelationshipClassA": { \
                  "description" : "this is a description", \
                  "modifier": "none", \
                  "schemaItemType":"RelationshipClass", \
                  "strength" : "referencing", \
                  "strengthDirection" : "forward", \
                  "source" : { \
                    "constraintClasses": [ "testSchema.EntityClassA" ], \
                    "multiplicity" : "(0..*)", \
                    "polymorphic" : false, \
                    "roleLabel": "relates to" \
                  }, \
                  "target" : { \
                    "constraintClasses" : [ "testSchema.EntityClassB" ], \
                    "multiplicity" : "(1..1)", \
                    "polymorphic": true, \
                    "roleLabel": "is related by" \
                  } \
                } \
              } \
            }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);

          // Act
          ECJsonMarkdownGenerator.writeRelationshipClass(outputFilePath, testSchema.getItemSync("RelationshipClassA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          const correctLines = [
            "### RelationshipClassA",
            "",
            "**typeName:** RelationshipClass",
            "",
            "this is a description",
            "",
            "**modifier:** None",
            "",
            "**Strength:** Referencing",
            "",
            "**strengthDirection:** Forward",
            "",
            "#### Source",
            "",
            "**isPolymorphic:** false",
            "",
            "**roleLabel:** relates to",
            "",
            "**multiplicity:** (0..*)",
            "",
            "##### Constraint Classes",
            "",
            '- [link_to testschema.ecschema/#entityclassa text="EntityClassA"]',
            "",
            "#### Target",
            "",
            "**isPolymorphic:** true",
            "",
            "**roleLabel:** is related by",
            "",
            "**multiplicity:** (1..1)",
            "",
            "##### Constraint Classes",
            "",
            '- [link_to testschema.ecschema/#entityclassb text="EntityClassB"]',
            "",
            "" ];

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write a class with a base class", () => {
          // Arrange
          const schemaJson = JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema", \
              "alias":"testSchema", \
              "name": "testSchema", \
              "version":"02.00.00", \
              "items": { \
                "EntityClassA": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassB": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassC": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassD": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "RelationshipClassA": { \
                  "baseClass" : "testSchema.EntityClassD", \
                  "modifier": "none", \
                  "schemaItemType":"RelationshipClass", \
                  "strength" : "referencing", \
                  "strengthDirection" : "forward", \
                  "source" : { \
                    "constraintClasses": [ "testSchema.EntityClassA" ], \
                    "multiplicity" : "(0..*)", \
                    "polymorphic" : false, \
                    "roleLabel": "relates to" \
                  }, \
                  "target" : { \
                    "constraintClasses" : [ "testSchema.EntityClassB" ], \
                    "multiplicity" : "(1..1)", \
                    "polymorphic": true, \
                    "roleLabel": "is related by" \
                  } \
                } \
              } \
            }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);

          // Act
          ECJsonMarkdownGenerator.writeRelationshipClass(outputFilePath, testSchema.getItemSync("RelationshipClassA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          const correctLines = [
            "### RelationshipClassA",
            "",
            "**typeName:** RelationshipClass",
            "",
            "**modifier:** None",
            "",
            '**baseClass:** [link_to testschema.ecschema/#entityclassd text="testSchema:EntityClassD"]',
            "",
            "**Strength:** Referencing",
            "",
            "**strengthDirection:** Forward",
            "",
            "#### Source",
            "",
            "**isPolymorphic:** false",
            "",
            "**roleLabel:** relates to",
            "",
            "**multiplicity:** (0..*)",
            "",
            "##### Constraint Classes",
            "",
            '- [link_to testschema.ecschema/#entityclassa text="EntityClassA"]',
            "",
            "#### Target",
            "",
            "**isPolymorphic:** true",
            "",
            "**roleLabel:** is related by",
            "",
            "**multiplicity:** (1..1)",
            "",
            "##### Constraint Classes",
            "",
            '- [link_to testschema.ecschema/#entityclassb text="EntityClassB"]',
            "",
            "" ];

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write a class with a label", () => {
          // Arrange
          const schemaJson = JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema", \
              "alias":"testSchema", \
              "name": "testSchema", \
              "version":"02.00.00", \
              "items": { \
                "EntityClassA": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassB": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassC": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassD": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "RelationshipClassA": { \
                  "baseClass" : "testSchema.EntityClassD", \
                  "modifier": "none", \
                  "schemaItemType":"RelationshipClass", \
                  "strength" : "referencing", \
                  "strengthDirection" : "forward", \
                  "source" : { \
                    "constraintClasses": [ "testSchema.EntityClassA" ], \
                    "multiplicity" : "(0..*)", \
                    "polymorphic" : false, \
                    "roleLabel": "relates to" \
                  }, \
                  "target" : { \
                    "constraintClasses" : [ "testSchema.EntityClassB" ], \
                    "multiplicity" : "(1..1)", \
                    "polymorphic": true, \
                    "roleLabel": "is related by" \
                  } \
                } \
              } \
            }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);

          // Act
          ECJsonMarkdownGenerator.writeRelationshipClass(outputFilePath, testSchema.getItemSync("RelationshipClassA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          const correctLines = [
            "### RelationshipClassA",
            "",
            "**typeName:** RelationshipClass",
            "",
            "**modifier:** None",
            "",
            '**baseClass:** [link_to testschema.ecschema/#entityclassd text="testSchema:EntityClassD"]',
            "",
            "**Strength:** Referencing",
            "",
            "**strengthDirection:** Forward",
            "",
            "#### Source",
            "",
            "**isPolymorphic:** false",
            "",
            "**roleLabel:** relates to",
            "",
            "**multiplicity:** (0..*)",
            "",
            "##### Constraint Classes",
            "",
            '- [link_to testschema.ecschema/#entityclassa text="EntityClassA"]',
            "",
            "#### Target",
            "",
            "**isPolymorphic:** true",
            "",
            "**roleLabel:** is related by",
            "",
            "**multiplicity:** (1..1)",
            "",
            "##### Constraint Classes",
            "",
            '- [link_to testschema.ecschema/#entityclassb text="EntityClassB"]',
            "",
            "" ];

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write a base class with description, base class, and label", () => {
          // Arrange
          const schemaJson = JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema", \
              "alias":"testSchema", \
              "name": "testSchema", \
              "version":"02.00.00", \
              "items": { \
                "EntityClassA": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassB": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassC": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassD": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "RelationshipClassA": { \
                  "label" : "relationshipClassALabel", \
                  "modifier": "none", \
                  "schemaItemType":"RelationshipClass", \
                  "strength" : "referencing", \
                  "strengthDirection" : "forward", \
                  "source" : { \
                    "constraintClasses": [ "testSchema.EntityClassA" ], \
                    "multiplicity" : "(0..*)", \
                    "polymorphic" : false, \
                    "roleLabel": "relates to" \
                  }, \
                  "target" : { \
                    "constraintClasses" : [ "testSchema.EntityClassB" ], \
                    "multiplicity" : "(1..1)", \
                    "polymorphic": true, \
                    "roleLabel": "is related by" \
                  } \
                } \
              } \
            }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);

          // Act
          ECJsonMarkdownGenerator.writeRelationshipClass(outputFilePath, testSchema.getItemSync("RelationshipClassA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          const correctLines = [
            "### RelationshipClassA",
            "",
            "**typeName:** RelationshipClass",
            "",
            "**displayLabel:** relationshipClassALabel",
            "",
            "**modifier:** None",
            "",
            "**Strength:** Referencing",
            "",
            "**strengthDirection:** Forward",
            "",
            "#### Source",
            "",
            "**isPolymorphic:** false",
            "",
            "**roleLabel:** relates to",
            "",
            "**multiplicity:** (0..*)",
            "",
            "##### Constraint Classes",
            "",
            '- [link_to testschema.ecschema/#entityclassa text="EntityClassA"]',
            "",
            "#### Target",
            "",
            "**isPolymorphic:** true",
            "",
            "**roleLabel:** is related by",
            "",
            "**multiplicity:** (1..1)",
            "",
            "##### Constraint Classes",
            "",
            '- [link_to testschema.ecschema/#entityclassb text="EntityClassB"]',
            "",
            "" ];

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write a class that has multiple constraint classes in target and source", () => {
          // Arrange
          const schemaJson = JSON.parse(
            '{\
              "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema", \
              "alias":"testSchema", \
              "name": "testSchema", \
              "version":"02.00.00", \
              "items": { \
                "EntityClassA": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassB": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassC": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassD": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassE": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassF": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "EntityClassG": { \
                  "schemaItemType":"EntityClass" \
                }, \
                "RelationshipClassA": { \
                  "modifier": "none", \
                  "schemaItemType":"RelationshipClass", \
                  "strength" : "referencing", \
                  "strengthDirection" : "forward", \
                  "source" : { \
                    "constraintClasses": [ \
                      "testSchema.EntityClassA", \
                      "testSchema.EntityClassB", \
                      "testSchema.EntityClassC" ], \
                    "multiplicity" : "(0..*)", \
                    "polymorphic" : false, \
                    "roleLabel": "relates to" \
                  }, \
                  "target" : { \
                    "constraintClasses" : [ \
                      "testSchema.EntityClassE", \
                      "testSchema.EntityClassF", \
                      "testSchema.EntityClassG" ], \
                    "multiplicity" : "(1..1)", \
                    "polymorphic": true, \
                    "roleLabel": "is related by" \
                  } \
                } \
              } \
            }');

          const context = new SchemaContext();
          const testSchema = Schema.fromJsonSync(schemaJson, context);

          // Act
          ECJsonMarkdownGenerator.writeRelationshipClass(outputFilePath, testSchema.getItemSync("RelationshipClassA"));

          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          const correctLines = [
            "### RelationshipClassA",
            "",
            "**typeName:** RelationshipClass",
            "",
            "**modifier:** None",
            "",
            "**Strength:** Referencing",
            "",
            "**strengthDirection:** Forward",
            "",
            "#### Source",
            "",
            "**isPolymorphic:** false",
            "",
            "**roleLabel:** relates to",
            "",
            "**multiplicity:** (0..*)",
            "",
            "##### Constraint Classes",
            "",
            '- [link_to testschema.ecschema/#entityclassa text="EntityClassA"]',
            '- [link_to testschema.ecschema/#entityclassb text="EntityClassB"]',
            '- [link_to testschema.ecschema/#entityclassc text="EntityClassC"]',
            "",
            "#### Target",
            "",
            "**isPolymorphic:** true",
            "",
            "**roleLabel:** is related by",
            "",
            "**multiplicity:** (1..1)",
            "",
            "##### Constraint Classes",
            "",
            '- [link_to testschema.ecschema/#entityclasse text="EntityClassE"]',
            '- [link_to testschema.ecschema/#entityclassf text="EntityClassF"]',
            '- [link_to testschema.ecschema/#entityclassg text="EntityClassG"]',
            "",
            "" ];

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });
      });

      describe("writeEnumerationItem", () => {
        const outputFilePath = path.join(outputDir, "relationshipClassTest.md");
        const schemaJson = JSON.parse(
          '{\
            "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema", \
            "alias":"testSchema", \
            "name": "testSchema", \
            "version":"02.00.00", \
            "items": { \
              "IntBackedEnum" : { \
                "backingTypeName" : "int", \
                "enumerators" : [ \
                  { \
                    "label" : "IntThing", \
                    "value" : 0 \
                  } \
                ], \
                "isStrict" : true, \
                "schemaItemType" : "Enumeration" \
              }, \
              "StringBackedEnum" : { \
                "backingTypeName" : "string", \
                "enumerators" : [ \
                  { \
                    "label" : "StringThing", \
                    "value" : "zero" \
                  } \
                ], \
                "isStrict" : true, \
                "schemaItemType" : "Enumeration" \
              }, \
              "NoEnumEnum" : { \
                "backingTypeName" : "string", \
                "enumerators" : [ ], \
                "isStrict" : true, \
                "schemaItemType" : "Enumeration" \
              }, \
              "LotsOfEnumEnum" : { \
                "backingTypeName" : "int", \
                "enumerators" : [ \
                  { \
                    "label" : "Zero", \
                    "value" : 0 \
                  }, \
                  { \
                    "label" : "One", \
                    "value" : 1 \
                  }, \
                  { \
                    "label" : "Two", \
                    "value" : 2 \
                  }, \
                  { \
                    "label" : "Three", \
                    "value" : 3 \
                  }, \
                  { \
                    "label" : "Four", \
                    "value" : 4 \
                  } \
                ], \
                "isStrict" : true, \
                "schemaItemType" : "Enumeration" \
              }, \
              "NoLabelEnumerators" : { \
                "backingTypeName" : "int", \
                "enumerators" : [ \
                  { "value" : 0 }, \
                  { "value" : 1 }, \
                  { "value" : 2 }, \
                  { "value" : 3 }, \
                  { "value" : 4 } \
                ], \
                "isStrict" : true, \
                "schemaItemType" : "Enumeration" \
              } \
            } \
          }');

        const context = new SchemaContext();
        const testSchema = Schema.fromJsonSync(schemaJson, context);

        // Delete the output file before each test
        beforeEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("should properly write an enumeration backed by int", () => {
          // Arrange
          const correctLines = [
            "### IntBackedEnum",
            "",
            "**typeName:** Enumeration",
            "",
            "**Backing Type:** int",
            "",
            "**Strict:** true",
            "",
            "|    Label    |    Value    |",
            "|:------------|:------------|",
            "|IntThing|0|",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeEnumerationItem(outputFilePath, testSchema.getItemSync("IntBackedEnum"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write an enumeration backed by a string", () => {
          // Arrange
          const correctLines = [
            "### StringBackedEnum",
            "",
            "**typeName:** Enumeration",
            "",
            "**Backing Type:** string",
            "",
            "**Strict:** true",
            "",
            "|    Label    |    Value    |",
            "|:------------|:------------|",
            "|StringThing|zero|",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeEnumerationItem(outputFilePath, testSchema.getItemSync("StringBackedEnum"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write an enumeration with no enumerators", () => {
          // Arrange
          const correctLines = [
            "### NoEnumEnum",
            "",
            "**typeName:** Enumeration",
            "",
            "**Backing Type:** string",
            "",
            "**Strict:** true",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeEnumerationItem(outputFilePath, testSchema.getItemSync("NoEnumEnum"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write an enumeration with several enumerators", () => {
          // Arrange
          const correctLines = [
            "### LotsOfEnumEnum",
            "",
            "**typeName:** Enumeration",
            "",
            "**Backing Type:** int",
            "",
            "**Strict:** true",
            "",
            "|    Label    |    Value    |",
            "|:------------|:------------|",
            "|Zero|0|",
            "|One|1|",
            "|Two|2|",
            "|Three|3|",
            "|Four|4|",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeEnumerationItem(outputFilePath, testSchema.getItemSync("LotsOfEnumEnum"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write an enumeration with no enumerator labels", () => {
          // Arrange
          const correctLines = [
            "### NoLabelEnumerators",
            "",
            "**typeName:** Enumeration",
            "",
            "**Backing Type:** int",
            "",
            "**Strict:** true",
            "",
            "|    Label    |    Value    |",
            "|:------------|:------------|",
            "||0|",
            "||1|",
            "||2|",
            "||3|",
            "||4|",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeEnumerationItem(outputFilePath, testSchema.getItemSync("NoLabelEnumerators"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });
      });

      describe("writeMixinClass", () => {
        const outputFilePath = path.join(outputDir, "mixinClassTest.md");
        const schemaJson = JSON.parse(
          '{ \
            "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema", \
            "alias":"testSchema", \
            "name": "testSchema", \
            "version":"02.00.00", \
            "items": { \
              "KOQA": {\
                "schemaItemType":"KindOfQuantity", \
                "persistenceUnit" : { \
                  "format" : "DefaultReal", \
                  "unit" : "A" \
                }, \
               "precision" : 0.0010, \
               "presentationUnits" : [ \
                  { \
                     "format" : "Real4U", \
                     "unit" : "A" \
                  } \
                ] \
              },\
              "KOQB": {\
                "schemaItemType":"KindOfQuantity", \
                "persistenceUnit" : { \
                  "format" : "DefaultReal", \
                  "unit" : "A" \
                }, \
               "precision" : 0.0010, \
               "presentationUnits" : [ \
                  { \
                     "format" : "Real4U", \
                     "unit" : "A" \
                  } \
                ] \
              },\
              "KOQC": {\
                "schemaItemType":"KindOfQuantity", \
                "persistenceUnit" : { \
                  "format" : "DefaultReal", \
                  "unit" : "A" \
                }, \
               "precision" : 0.0010, \
               "presentationUnits" : [ \
                  { \
                     "format" : "Real4U", \
                     "unit" : "A" \
                  } \
                ] \
              }, \
              "KOQD": {\
                "schemaItemType":"KindOfQuantity", \
                "persistenceUnit" : { \
                  "format" : "DefaultReal", \
                  "unit" : "A" \
                }, \
               "precision" : 0.0010, \
               "presentationUnits" : [ \
                  { \
                     "format" : "Real4U", \
                     "unit" : "A" \
                  } \
                ] \
              }, \
              "EntityA" : { \
                "schemaItemType" : "EntityClass" \
               }, \
               "EntityB" : { \
                "schemaItemType" : "EntityClass" \
               }, \
              "PlainMixin" : { \
                "appliesTo" : "testSchema.EntityA", \
                "schemaItemType" : "Mixin" \
              }, \
              "MixinWithDescription" : { \
                "appliesTo" : "testSchema.EntityA", \
                "description" : "this is a description", \
                "schemaItemType" : "Mixin" \
              }, \
              "MixinWithBaseclass" : { \
                "appliesTo" : "testSchema.EntityA", \
                "baseClass" : "testSchema.EntityB", \
                "schemaItemType" : "Mixin" \
              }, \
              "MixinWithLabel" : { \
                "appliesTo" : "testSchema.EntityA", \
                "schemaItemType" : "Mixin", \
                "label" : "MixinLabel" \
              }, \
              "MixinWithDBL" : { \
                "appliesTo" : "testSchema.EntityA", \
                "schemaItemType" : "Mixin", \
                "description" : "this is a description", \
                "baseClass" : "testSchema.EntityB", \
                "label" : "MixinLabel" \
              }, \
              "MixinWithProperties" : { \
                "appliesTo" : "testSchema.EntityA", \
                "schemaItemType" : "Mixin", \
                "properties" : [ \
                  { \
                    "kindOfQuantity" : "testSchema.KOQA", \
                    "name" : "propertyA", \
                    "propertyType" : "PrimitiveProperty", \
                    "typeName" : "double" \
                  }, \
                  { \
                    "kindOfQuantity" : "testSchema.KOQB", \
                    "label" : "propertyBLabel", \
                    "name" : "propertyB", \
                    "propertyType" : "PrimitiveProperty", \
                    "typeName" : "double" \
                  }, \
                  { \
                    "kindOfQuantity" : "testSchema.KOQC", \
                    "label" : "propertyCLabel", \
                    "name" : "propertyC", \
                    "propertyType" : "PrimitiveProperty", \
                    "typeName" : "double", \
                    "isReadOnly" : true \
                  }, \
                  { \
                    "kindOfQuantity" : "testSchema.KOQD", \
                    "label" : "propertyDLabel", \
                    "name" : "propertyD", \
                    "propertyType" : "PrimitiveProperty", \
                    "typeName" : "double", \
                    "readOnly" : true, \
                    "priority" : 1 \
                  } \
                ] \
              }, \
              "MixinWithAll" : { \
                "description" : "this is a description", \
                "baseClass" : "testSchema.EntityB", \
                "label" : "MixinLabel", \
                "appliesTo" : "testSchema.EntityA", \
                "schemaItemType" : "Mixin", \
                "properties" : [ \
                  { \
                    "kindOfQuantity" : "testSchema.KOQD", \
                    "label" : "propertyDLabel", \
                    "name" : "propertyD", \
                    "propertyType" : "PrimitiveProperty", \
                    "typeName" : "double", \
                    "readOnly" : true, \
                    "priority" : 1 \
                   } \
                ] \
              } \
            } \
          }');

        const context = new SchemaContext();
        const testSchema = Schema.fromJsonSync(schemaJson, context);

        // Delete the output file before each test
        beforeEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("it should properly write a mixin that has no description, base class, label, or properties", () => {
          // Arrange
          const correctLines = [
            "### PlainMixin",
            "",
            "**typeName:** Mixin",
            "",
            "**modifier:** Abstract",
            "",
            '**appliesTo:** [link_to testschema.ecschema/#entitya text="EntityA"]',
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeMixinClass(outputFilePath, testSchema.getItemSync("PlainMixin"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("it should properly write a mixin that has a description", () => {
          // Arrange
          const correctLines = [
            "### MixinWithDescription",
            "",
            "**typeName:** Mixin",
            "",
            "this is a description",
            "",
            "**modifier:** Abstract",
            "",
            '**appliesTo:** [link_to testschema.ecschema/#entitya text="EntityA"]',
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeMixinClass(outputFilePath, testSchema.getItemSync("MixinWithDescription"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("it should properly write a mixin that has a base class", () => {
          // Arrange
          const correctLines = [
            "### MixinWithBaseclass",
            "",
            "**typeName:** Mixin",
            "",
            "**modifier:** Abstract",
            "",
            '**baseClass:** [link_to testschema.ecschema/#entityb text="testSchema:EntityB"]',
            "",
            '**appliesTo:** [link_to testschema.ecschema/#entitya text="EntityA"]',
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeMixinClass(outputFilePath, testSchema.getItemSync("MixinWithBaseclass"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("it should properly write a mixin that has a label", () => {
          // Arrange
          const correctLines = [
            "### MixinWithLabel",
            "",
            "**typeName:** Mixin",
            "",
            "**displayLabel:** MixinLabel",
            "",
            "**modifier:** Abstract",
            "",
            '**appliesTo:** [link_to testschema.ecschema/#entitya text="EntityA"]',
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeMixinClass(outputFilePath, testSchema.getItemSync("MixinWithLabel"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("it should properly write a mixin that has a base class, label, and description", () => {
          // Arrange
          const correctLines = [
            "### MixinWithDBL",
            "",
            "**typeName:** Mixin",
            "",
            "this is a description",
            "",
            "**displayLabel:** MixinLabel",
            "",
            "**modifier:** Abstract",
            "",
            '**baseClass:** [link_to testschema.ecschema/#entityb text="testSchema:EntityB"]',
            "",
            '**appliesTo:** [link_to testschema.ecschema/#entitya text="EntityA"]',
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeMixinClass(outputFilePath, testSchema.getItemSync("MixinWithDBL"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("it should properly write a mixin that has several properties", () => {
          // Arrange
          const correctLines = [
            "### MixinWithProperties",
            "",
            "**typeName:** Mixin",
            "",
            "**modifier:** Abstract",
            "",
            '**appliesTo:** [link_to testschema.ecschema/#entitya text="EntityA"]',
            "",
            "#### Properties",
            "",
            "|    Name    | Description |    Label    |  Category  |    Read Only     |    Priority    |",
            "|:-----------|:------------|:------------|:-----------|:-----------------|:---------------|",
            "|propertyA||||false|0|",
            "|propertyB||propertyBLabel||false|0|",
            "|propertyC||propertyCLabel||false|0|",
            "|propertyD||propertyDLabel||true|1|",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeMixinClass(outputFilePath, testSchema.getItemSync("MixinWithProperties"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("it should properly write a mixin that has all attributes", () => {
          // Arrange
          const correctLines = [
            "### MixinWithAll",
            "",
            "**typeName:** Mixin",
            "",
            "this is a description",
            "",
            "**displayLabel:** MixinLabel",
            "",
            "**modifier:** Abstract",
            "",
            '**baseClass:** [link_to testschema.ecschema/#entityb text="testSchema:EntityB"]',
            "",
            '**appliesTo:** [link_to testschema.ecschema/#entitya text="EntityA"]',
            "",
            "#### Properties",
            "",
            "|    Name    | Description |    Label    |  Category  |    Read Only     |    Priority    |",
            "|:-----------|:------------|:------------|:-----------|:-----------------|:---------------|",
            "|propertyD||propertyDLabel||true|1|",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeMixinClass(outputFilePath, testSchema.getItemSync("MixinWithAll"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });
      });

      describe("writeCustomAttributeClass", () => {

        const outputFilePath = path.join(outputDir, "customAttributeClassTest.md");
        const schemaJson = JSON.parse(
          '{ \
            "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema", \
            "alias":"testSchema", \
            "name": "testSchema", \
            "version":"02.00.00", \
            "items": { \
              "EntityA" : { "schemaItemType" : "EntityClass" }, \
              "PlainCAC" : { \
                "appliesTo" : "AnyProperty", \
                "modifier" : "sealed", \
                "schemaItemType" : "CustomAttributeClass" \
              }, \
              "CACWithDescription" : { \
                "appliesTo" : "AnyProperty", \
                "description" : "this is a description", \
                "modifier" : "sealed", \
                "schemaItemType" : "CustomAttributeClass" \
              }, \
              "CACWithBaseClass" : { \
                "appliesTo" : "AnyProperty", \
                "description" : "this is a description", \
                "baseClass" : "testSchema.EntityA", \
                "modifier" : "sealed", \
                "schemaItemType" : "CustomAttributeClass" \
              }, \
              "CACWithProperties" : { \
                "appliesTo" : "AnyProperty", \
                "description" : "this is a description", \
                "baseClass" : "testSchema.EntityA", \
                "modifier" : "sealed", \
                "schemaItemType" : "CustomAttributeClass", \
                "properties" : [ \
                  { \
                    "name" : "PropertyA", \
                    "label" : "PropertyALabel", \
                    "propertyType" : "PrimitiveProperty", \
                    "typeName" : "boolean" \
                  } \
                ] \
              }, \
              "CACWithMultipleProperties" : { \
                "appliesTo" : "AnyProperty", \
                "schemaItemType" : "CustomAttributeClass", \
                "properties" : [ \
                  { \
                    "name" : "PropertyA", \
                    "propertyType" : "PrimitiveProperty", \
                    "typeName" : "boolean" \
                  }, \
                  { \
                    "name" : "PropertyB", \
                    "label" : "PropertyBLabel", \
                    "propertyType" : "PrimitiveProperty", \
                    "typeName" : "boolean", \
                    "readOnly" : true \
                  }, \
                  { \
                    "name" : "PropertyC", \
                    "label" : "PropertyCLabel", \
                    "propertyType" : "PrimitiveProperty", \
                    "typeName" : "boolean", \
                    "readOnly" : true, \
                    "priority" : 1 \
                  } \
                ] \
              } \
            } \
          }');

        const context = new SchemaContext();
        const testSchema = Schema.fromJsonSync(schemaJson, context);

        // Delete the output file before each test
        beforeEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("should write a class without description, base class, or properties", () => {
          // Arrange
          const correctLines = [
            "### PlainCAC",
            "",
            "**typeName:** CustomAttributeClass",
            "",
            "**modifier:** Sealed",
            "",
            "**Applies to:** AnyProperty",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeCustomAttributeClass(outputFilePath, testSchema.getItemSync("PlainCAC"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write a class that has a description", () => {
          // Arrange
          const correctLines = [
            "### CACWithDescription",
            "",
            "**typeName:** CustomAttributeClass",
            "",
            "this is a description",
            "",
            "**modifier:** Sealed",
            "",
            "**Applies to:** AnyProperty",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeCustomAttributeClass(outputFilePath, testSchema.getItemSync("CACWithDescription"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write a class with a description and a base class", () => {
          // Arrange
          const correctLines = [
            "### CACWithBaseClass",
            "",
            "**typeName:** CustomAttributeClass",
            "",
            "this is a description",
            "",
            "**modifier:** Sealed",
            "",
            '**baseClass:** [link_to testschema.ecschema/#entitya text="testSchema:EntityA"]',
            "",
            "**Applies to:** AnyProperty",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeCustomAttributeClass(outputFilePath, testSchema.getItemSync("CACWithBaseClass"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write a class that has a description, base class, and properties", () => {
          // Arrange
          const correctLines = [
            "### CACWithProperties",
            "",
            "**typeName:** CustomAttributeClass",
            "",
            "this is a description",
            "",
            "**modifier:** Sealed",
            "",
            '**baseClass:** [link_to testschema.ecschema/#entitya text="testSchema:EntityA"]',
            "",
            "**Applies to:** AnyProperty",
            "",
            "#### Properties",
            "",
            "|    Name    | Description |    Label    |  Category  |    Read Only     |    Priority    |",
            "|:-----------|:------------|:------------|:-----------|:-----------------|:---------------|",
            "|PropertyA||PropertyALabel||false|0|",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeCustomAttributeClass(outputFilePath, testSchema.getItemSync("CACWithProperties"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write a class that has several properties", () => {
          // Arrange
          const correctLines = [
            "### CACWithMultipleProperties",
            "",
            "**typeName:** CustomAttributeClass",
            "",
            "**modifier:** None",
            "",
            "**Applies to:** AnyProperty",
            "",
            "#### Properties",
            "",
            "|    Name    | Description |    Label    |  Category  |    Read Only     |    Priority    |",
            "|:-----------|:------------|:------------|:-----------|:-----------------|:---------------|",
            "|PropertyA||||false|0|",
            "|PropertyB||PropertyBLabel||true|0|",
            "|PropertyC||PropertyCLabel||true|1|",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeCustomAttributeClass(outputFilePath, testSchema.getItemSync("CACWithMultipleProperties"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });
      });

      describe("writeStructClass", () => {
        const outputFilePath = path.join(outputDir, "structClassTest.md");
        const schemaJson = JSON.parse(
          '{ \
            "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema", \
            "alias":"testSchema", \
            "name": "testSchema", \
            "version":"02.00.00", \
            "items": { \
              "EntityA" : { \
                "schemaItemType" : "EntityClass" \
              }, \
              "PlainStruct" : { \
                "modifier" : "sealed", \
                "schemaItemType" : "StructClass" \
              }, \
              "StructD" : { \
                "modifier" : "sealed", \
                "description" : "this is a description", \
                "schemaItemType" : "StructClass" \
              }, \
              "StructDL" : { \
                "modifier" : "sealed", \
                "description" : "this is a description", \
                "label" : "StructDLLabel", \
                "schemaItemType" : "StructClass" \
              }, \
              "StructDLB" : { \
                "modifier" : "sealed", \
                "description"  : "this is a description", \
                "label" : "StructDLBLabel", \
                "baseClass" : "testSchema.EntityA", \
                "schemaItemType" : "StructClass" \
              }, \
              "StructDLBP" : { \
                "modifier" : "sealed", \
                "description" : "this is a description", \
                "label" : "StructDLBPLabel", \
                "baseClass" : "testSchema.EntityA", \
                "schemaItemType" : "StructClass", \
                "properties" : [ \
                  { \
                    "name" : "propertyA", \
                    "propertyType" : "PrimitiveProperty", \
                    "typeName" : "string" \
                  } \
                ] \
              }, \
              "StructProperties" : { \
                "modifier" : "sealed", \
                "schemaItemType" : "StructClass", \
                "properties" : [ \
                  { \
                    "name" : "propertyA", \
                    "propertyType" : "PrimitiveProperty", \
                    "typeName" : "string" \
                  }, \
                  { \
                    "name" : "propertyB", \
                    "propertyType" : "PrimitiveProperty", \
                    "typeName" : "string", \
                    "readOnly" : true \
                  }, \
                  { \
                    "name" : "propertyV", \
                    "propertyType" : "PrimitiveProperty", \
                    "typeName" : "string", \
                    "priority" : 1 \
                  } \
                ] \
              } \
            } \
          }');

        const context = new SchemaContext();
        const testSchema = Schema.fromJsonSync(schemaJson, context);

        // Delete the output file before each test
        beforeEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("should properly write a class without a description, label, base class, or properties", () => {
          // Arrange
          const correctLines = [
            "### PlainStruct",
            "",
            "**typeName:** StructClass",
            "",
            "**modifier:** Sealed",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeStructClass(outputFilePath, testSchema.getItemSync("PlainStruct"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write a class that has a description", () => {
          // Arrange
          const correctLines = [
            "### StructD",
            "",
            "**typeName:** StructClass",
            "",
            "this is a description",
            "",
            "**modifier:** Sealed",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeStructClass(outputFilePath, testSchema.getItemSync("StructD"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write a class that has a description and label", () => {
          // Arrange
          const correctLines = [
            "### StructDL",
            "",
            "**typeName:** StructClass",
            "",
            "this is a description",
            "",
            "**displayLabel:** StructDLLabel",
            "",
            "**modifier:** Sealed",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeStructClass(outputFilePath, testSchema.getItemSync("StructDL"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write a class that has a description, label, and base class", () => {
          // Arrange
          const correctLines = [
            "### StructDLB",
            "",
            "**typeName:** StructClass",
            "",
            "this is a description",
            "",
            "**displayLabel:** StructDLBLabel",
            "",
            "**modifier:** Sealed",
            "",
            '**baseClass:** [link_to testschema.ecschema/#entitya text="testSchema:EntityA"]',
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeStructClass(outputFilePath, testSchema.getItemSync("StructDLB"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write a class that a description, label, base class, and properties", () => {
          // Arrange
          const correctLines = [
            "### StructDLBP",
            "",
            "**typeName:** StructClass",
            "",
            "this is a description",
            "",
            "**displayLabel:** StructDLBPLabel",
            "",
            "**modifier:** Sealed",
            "",
            '**baseClass:** [link_to testschema.ecschema/#entitya text="testSchema:EntityA"]',
            "",
            "#### Properties",
            "",
            "|    Name    |  Description  |    Label    |  Category  |    Read Only     |    Priority    |",
            "|:-----------|:--------------|:------------|:-----------|:-----------------|:---------------|",
            "|propertyA||||false|0|",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeStructClass(outputFilePath, testSchema.getItemSync("StructDLBP"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write a class that has several properties", () => {
          // Arrange
          const correctLines = [
            "### StructProperties",
            "",
            "**typeName:** StructClass",
            "",
            "**modifier:** Sealed",
            "",
            "#### Properties",
            "",
            "|    Name    |  Description  |    Label    |  Category  |    Read Only     |    Priority    |",
            "|:-----------|:--------------|:------------|:-----------|:-----------------|:---------------|",
            "|propertyA||||false|0|",
            "|propertyB||||true|0|",
            "|propertyV||||false|1|",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writeStructClass(outputFilePath, testSchema.getItemSync("StructProperties"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });
      });

      describe("writePropertyCategory", () => {
        const outputFilePath = path.join(outputDir, "structClassTest.md");
        const schemaJson = JSON.parse(
          '{ \
            "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema", \
            "alias":"testSchema", \
            "name": "testSchema", \
            "version":"02.00.00", \
            "items": { \
              "PlainPropCategory" : { \
                "schemaItemType" : "PropertyCategory" \
              }, \
              "PropCategoryD" : { \
                "schemaItemType" : "PropertyCategory", \
                "description" : "this is a description" \
              }, \
              "PropCategoryDL" : { \
                "schemaItemType" : "PropertyCategory", \
                "description" : "this is a description", \
                "label" : "PropCategoryDLLabel" \
              } \
            } \
          }');

        const context = new SchemaContext();
        const testSchema = Schema.fromJsonSync(schemaJson, context);

        // Delete the output file before each test
        beforeEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        // Delete the output file after each test
        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("should properly write property category with no description or label", () => {
          // Arrange
          const correctLines = [
            "### PlainPropCategory",
            "",
            "**typeName:** PropertyCategory",
            "",
            "**priority:** 0",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writePropertyCategory(outputFilePath, testSchema.getItemSync("PlainPropCategory"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write property category with a description", () => {
          // Arrange
          const correctLines = [
            "### PropCategoryD",
            "",
            "**typeName:** PropertyCategory",
            "",
            "this is a description",
            "",
            "**priority:** 0",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writePropertyCategory(outputFilePath, testSchema.getItemSync("PropCategoryD"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });

        it("should properly write property category with a description and label", () => {
          // Arrange
          const correctLines = [
            "### PropCategoryDL",
            "",
            "**typeName:** PropertyCategory",
            "",
            "this is a description",
            "",
            "**displayLabel:** PropCategoryDLLabel",
            "",
            "**priority:** 0",
            "",
            "" ];

          // Act
          ECJsonMarkdownGenerator.writePropertyCategory(outputFilePath, testSchema.getItemSync("PropCategoryDL"));
          // Assert
          const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");

          // tslint:disable-next-line:prefer-for-of
          for (let i = 0; i < outputLines.length; i++)
            assert.equal(outputLines[i], correctLines[i]);
        });
      });

      describe("Misc", () => {
        describe("getSortedSchemaItems", () => {
          const schemaJson = JSON.parse(
          '{\
            "$schema":"https://dev.bentley.com/json_schemas/ec/31/draft-01/ecschema",\
            "description":"This is the description",\
            "alias":"testSchema",\
            "name": "testSchema",\
            "version":"02.00.00",\
            "items": { \
              "EntityClassB": {\
                "description": "this is a description", \
                "schemaItemType":"EntityClass"\
              },\
              "EntityClassC":{\
                "schemaItemType":"EntityClass"\
              },\
              "EntityClassA":{\
                "schemaItemType":"EntityClass"\
              },\
              "CustomAttributeClassB":{\
                "schemaItemType":"CustomAttributeClass", \
                "appliesTo" : "AnyProperty" \
              },\
              "CustomAttributeClassC":{\
                "schemaItemType":"CustomAttributeClass", \
                "appliesTo" : "AnyProperty" \
              },\
              "CustomAttributeClassA":{\
                "schemaItemType":"CustomAttributeClass", \
                "appliesTo" : "AnyProperty" \
              },\
              "EnumerationB":{\
                "backingTypeName" : "int", \
                "schemaItemType":"Enumeration"\
              },\
              "EnumerationC":{\
                "backingTypeName" : "int", \
                "schemaItemType":"Enumeration"\
              },\
              "EnumerationA":{\
                "backingTypeName" : "int",  \
                "schemaItemType":"Enumeration"\
              },\
              "KindOfQuantityB":{\
                "schemaItemType":"KindOfQuantity"\
              },\
              "KindOfQuantityC":{\
                "schemaItemType":"KindOfQuantity"\
              },\
              "KindOfQuantityA":{\
                "schemaItemType":"KindOfQuantity"\
              },\
              "RelationshipClassB":{\
                "source" :{\
                  "constraintClasses" : [ "testSchema.KindOfQuantityA" ],\
                  "multiplicity" : "(0..1)",\
                  "polymorphic" : true,\
                  "roleLabel" : "owns"\
                },\
                "target" :{\
                  "constraintClasses" : [ "testSchema.KindOfQuantityB" ],\
                  "multiplicity" : "(0..*)",\
                  "polymorphic" : false,\
                  "roleLabel" : "is owned by"\
                },\
                "schemaItemType":"RelationshipClass"\
              },\
              "RelationshipClassC":{\
                "source" :{\
                  "constraintClasses" : [ "testSchema.KindOfQuantityA" ],\
                  "multiplicity" : "(0..1)",\
                  "polymorphic" : true,\
                  "roleLabel" : "owns"\
                },\
                "target" :{\
                  "constraintClasses" : [ "testSchema.KindOfQuantityB" ],\
                  "multiplicity" : "(0..*)",\
                  "polymorphic" : false,\
                  "roleLabel" : "is owned by"\
                },\
                "schemaItemType":"RelationshipClass"\
              },\
              "RelationshipClassA":{\
                "source" :{\
                  "constraintClasses" : [ "testSchema.KindOfQuantityA" ],\
                  "multiplicity" : "(0..1)",\
                  "polymorphic" : true,\
                  "roleLabel" : "owns"\
                },\
                "target" :{\
                  "constraintClasses" : [ "testSchema.KindOfQuantityB" ],\
                  "multiplicity" : "(0..*)",\
                  "polymorphic" : false,\
                  "roleLabel" : "is owned by"\
                },\
                "schemaItemType":"RelationshipClass"\
              },\
              "MixinB":{\
                "schemaItemType":"Mixin", \
                "appliesTo" : "testSchema.EntityClassB" \
              },\
              "MixinC":{\
                "schemaItemType":"Mixin", \
                "appliesTo" : "testSchema.EntityClassC" \
              },\
              "MixinA":{\
                "schemaItemType":"Mixin", \
                "appliesTo" : "testSchema.EntityClassA" \
              },\
              "PropertyCategoryB":{\
                "schemaItemType":"PropertyCategory"\
              },\
              "PropertyCategoryC":{\
                "schemaItemType":"PropertyCategory"\
              },\
              "PropertyCategoryA":{\
                "schemaItemType":"PropertyCategory"\
              }\
            }\
          }');

          let testSchema: Schema;

          before(() => {
            // Load up the schema
            const context = new SchemaContext();
            testSchema = Schema.fromJsonSync(schemaJson, context);
          });

          it("should return the sorted EntityClasses", () => {
            const sortedItems = ECJsonMarkdownGenerator.getSortedSchemaItems(testSchema, "EntityClass");

            assert.equal(sortedItems[0].name, "EntityClassA");
            assert.equal(sortedItems[1].name, "EntityClassB");
            assert.equal(sortedItems[2].name, "EntityClassC");
          });

          it("should return the sorted CustomAttributeClasses", () => {
            const sortedItems = ECJsonMarkdownGenerator.getSortedSchemaItems(testSchema, "CustomAttributeClass");

            assert.equal(sortedItems[0].name, "CustomAttributeClassA");
            assert.equal(sortedItems[1].name, "CustomAttributeClassB");
            assert.equal(sortedItems[2].name, "CustomAttributeClassC");
          });

          it("should return the sorted Enumerations", () => {
            const sortedItems = ECJsonMarkdownGenerator.getSortedSchemaItems(testSchema, "Enumeration");

            assert.equal(sortedItems[0].name, "EnumerationA");
            assert.equal(sortedItems[1].name, "EnumerationB");
            assert.equal(sortedItems[2].name, "EnumerationC");
          });

          it("should return the sorted KindOfQuantities", () => {
            const sortedItems = ECJsonMarkdownGenerator.getSortedSchemaItems(testSchema, "KindOfQuantity");

            assert.equal(sortedItems[0].name, "KindOfQuantityA");
            assert.equal(sortedItems[1].name, "KindOfQuantityB");
            assert.equal(sortedItems[2].name, "KindOfQuantityC");
          });

          it("should return the sorted RelationshipClasses", () => {
            const sortedItems = ECJsonMarkdownGenerator.getSortedSchemaItems(testSchema, "RelationshipClass");

            assert.equal(sortedItems[0].name, "RelationshipClassA");
            assert.equal(sortedItems[1].name, "RelationshipClassB");
            assert.equal(sortedItems[2].name, "RelationshipClassC");
          });

          it("should return the sorted Mixins", () => {
            const sortedItems = ECJsonMarkdownGenerator.getSortedSchemaItems(testSchema, "Mixin");

            assert.equal(sortedItems[0].name, "MixinA");
            assert.equal(sortedItems[1].name, "MixinB");
            assert.equal(sortedItems[2].name, "MixinC");
          });

          it("should return the sorted list of property categories", () => {
            const sortedItems = ECJsonMarkdownGenerator.getSortedSchemaItems(testSchema, "PropertyCategory");

            assert.equal(sortedItems[0].name, "PropertyCategoryA");
            assert.equal(sortedItems[1].name, "PropertyCategoryB");
            assert.equal(sortedItems[2].name, "PropertyCategoryC");
          });
        });

        describe("formatLink", () => {
          it("should correctly format a link for bemetalsmith", () => {
            const link = formatLink("https://www.google.com", "Google");
            assert.equal(link, '[link_to https://www.google.com text="Google"]');
          });
        });

        describe("formatWarningAlert", () => {
          it("should properly format a warning alert for bemetalsmith", () => {
            const warning = formatWarningAlert("This is a warning");
            assert.equal(warning, '[!alert text="This is a warning" kind="warning"]');
          });
        });

        describe("propertyTypeNumberToString", () => {
          it("should return the correct type for each number", () => {
            assert.equal(propertyTypeNumberToString(PropertyType.Struct), "struct");
            assert.equal(propertyTypeNumberToString(PropertyType.Struct_Array), "struct array");
            assert.equal(propertyTypeNumberToString(PropertyType.Navigation), "navigation");
            assert.equal(propertyTypeNumberToString(PropertyType.Binary), "binary");
            assert.equal(propertyTypeNumberToString(PropertyType.Binary_Array), "binary array");
            assert.equal(propertyTypeNumberToString(PropertyType.Boolean), "boolean");
            assert.equal(propertyTypeNumberToString(PropertyType.Boolean_Array), "boolean array");
            assert.equal(propertyTypeNumberToString(PropertyType.DateTime), "dateTime");
            assert.equal(propertyTypeNumberToString(PropertyType.DateTime_Array), "dateTime array");
            assert.equal(propertyTypeNumberToString(PropertyType.Double), "double");
            assert.equal(propertyTypeNumberToString(PropertyType.Double_Array), "double array");
            assert.equal(propertyTypeNumberToString(PropertyType.Integer), "int");
            assert.equal(propertyTypeNumberToString(PropertyType.Integer_Array), "int array");
            assert.equal(propertyTypeNumberToString(PropertyType.Integer_Enumeration), "int enum");
            assert.equal(propertyTypeNumberToString(PropertyType.Integer_Enumeration_Array), "int enum array");
            assert.equal(propertyTypeNumberToString(PropertyType.Long), "long");
            assert.equal(propertyTypeNumberToString(PropertyType.Long_Array), "long array");
            assert.equal(propertyTypeNumberToString(PropertyType.Point2d), "point2d");
            assert.equal(propertyTypeNumberToString(PropertyType.Point2d_Array), "point2d array");
            assert.equal(propertyTypeNumberToString(PropertyType.Point3d), "point3d");
            assert.equal(propertyTypeNumberToString(PropertyType.Point3d_Array), "point3d array");
            assert.equal(propertyTypeNumberToString(PropertyType.String), "string");
            assert.equal(propertyTypeNumberToString(PropertyType.String_Array), "string array");
            assert.equal(propertyTypeNumberToString(PropertyType.String_Enumeration), "string enum");
            assert.equal(propertyTypeNumberToString(PropertyType.String_Enumeration_Array), "string enum array");
            assert.equal(propertyTypeNumberToString(PropertyType.IGeometry), "IGeometry");
            assert.equal(propertyTypeNumberToString(PropertyType.IGeometry_Array), "IGeometry array");
          });
        });

        describe("integration tests", () => {
          const inputFileDir = path.join(".", "test", "Assets", "dir");
          let testMDGenerator: ECJsonMarkdownGenerator;
          let outputFilePath: string;

          // Delete the output file before each test
          beforeEach(() => {
            if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
            testMDGenerator = new ECJsonMarkdownGenerator([inputFileDir]);
          });

          // Delete the output file after each test
          afterEach(() => {
            if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
          });

          it("should properly generate markdown for biscore", () => {
            // Assert
            const inputFileName = "BisCore.ecschema";
            const inputFilePath = path.join(inputFileDir, inputFileName + ".json");
            const correctFilePath = path.join(inputFileDir, inputFileName + ".md");
            outputFilePath = path.join(outputDir, inputFileName + ".md");

            // Act
            testMDGenerator.generate(inputFilePath, outputFilePath);

            // Assert
            const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
            const correctLines = fs.readFileSync(correctFilePath).toString().split("\n");

            // tslint:disable-next-line:prefer-for-of
            for (let i = 0; i < outputLines.length; i++)
              assert.equal(outputLines[i], correctLines[i]);
          });

          it("should properly generate markdown for AecUnits", () => {
            // Assert
            const inputFileName = "AecUnits.ecschema";
            const inputFilePath = path.join(inputFileDir, inputFileName + ".json");
            const correctFilePath = path.join(inputFileDir, inputFileName + ".md");
            outputFilePath = path.join(outputDir, inputFileName + ".md");

            // Act
            testMDGenerator.generate(inputFilePath, outputFilePath);

            // Assert
            const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
            const correctLines = fs.readFileSync(correctFilePath).toString().split("\n");

            // tslint:disable-next-line:prefer-for-of
            for (let i = 0; i < outputLines.length; i++)
              assert.equal(outputLines[i], correctLines[i]);
          });

          it("should properly generate markdown for CoreCustomAttributes", () => {
            // Assert
            const inputFileName = "CoreCustomAttributes.ecschema";
            const inputFilePath = path.join(inputFileDir, inputFileName + ".json");
            const correctFilePath = path.join(inputFileDir, inputFileName + ".md");
            outputFilePath = path.join(outputDir, inputFileName + ".md");

            // Act
            testMDGenerator.generate(inputFilePath, outputFilePath);

            // Assert
            const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
            const correctLines = fs.readFileSync(correctFilePath).toString().split("\n");

            // tslint:disable-next-line:prefer-for-of
            for (let i = 0; i < outputLines.length; i++)
              assert.equal(outputLines[i], correctLines[i]);
          });

          it("should properly generate markdown for Grids", () => {
            // Assert
            const inputFileName = "Grids.ecschema";
            const inputFilePath = path.join(inputFileDir, inputFileName + ".json");
            const correctFilePath = path.join(inputFileDir, inputFileName + ".md");
            outputFilePath = path.join(outputDir, inputFileName + ".md");

            // Act
            testMDGenerator.generate(inputFilePath, outputFilePath);

            // Assert
            const outputLines = fs.readFileSync(outputFilePath).toString().split("\n");
            const correctLines = fs.readFileSync(correctFilePath).toString().split("\n");

            // tslint:disable-next-line:prefer-for-of
            for (let i = 0; i < outputLines.length; i++)
              assert.equal(outputLines[i], correctLines[i]);
          });
        });
      });
    });

    describe("others", () => {
      describe("removeExtraBlankLine", () => {
        const outputFilePath = path.join(".", "test", "_temp_remove_line_.txt");

        beforeEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        afterEach(() => {
          if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath);
        });

        it("should remove extra blank line at the end of file", () => {
          // Assert
          const inputFilePath = path.join(".", "test", "Assets", "file_with_blank_lines.txt");

          // Act
          removeExtraBlankLine(inputFilePath, outputFilePath);

          // Assert
          const outputBuffer = fs.readFileSync(outputFilePath).toString();
          const correctBuffer = "test\n";
          assert.equal(outputBuffer, correctBuffer);
        });

        it("shouldn't remove an extra blank line if there isn't one there", () => {
          // Assert
          const inputFilePath = path.join(".", "test", "Assets", "file_with_blank_line.txt");

          // Act
          removeExtraBlankLine(inputFilePath, outputFilePath);

          // Assert
          const outputBuffer = fs.readFileSync(outputFilePath).toString();
          const correctBuffer = "test\n";
          assert.equal(outputBuffer, correctBuffer);
        });

        it("shouldn't do anything to a file with no blank lines", () => {
          // Assert
          const inputFilePath = path.join(".", "test", "Assets", "file_with_no_blank_line.txt");

          // Act
          removeExtraBlankLine(inputFilePath, outputFilePath);

          // Assert
          const outputBuffer = fs.readFileSync(outputFilePath).toString();
          const correctBuffer = "test";
          assert.equal(outputBuffer, correctBuffer);
        });
      });
    });
  });
});
